浮动元素会被移出正常文档流，并被拉到容器边缘。文档流会重新排列，但是它会包围浮动元素此刻所占据的空间。如果让多个元素向同侧浮动，它们就会挨着排列。

一开始设计浮动是为了实现文字围绕浮动元素排列的效果。`display: inline-block`和`display: table`的问世才让我们有了别的方案，尽管二者可替代的场景有限。Flexbox和网格布局最近几年才出现，在它们出现之前，浮动一直承担着页面布局的重任。
布局最简单的方式是先将网页的大块区域布局好，再逐级布局内部的小元素。

这是因为浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上。

![浮动会脱离文档流](float-bg.png)

## 清除浮动

1. 添加`<div style="clear: both;"></div>`至容器的末尾。

   `clear: both`声明让该元素移动到浮动元素的下面，而不是侧面。clear的值还可以设置为left或者right，这样只会相应地清除向左或者向右浮动的元素。因为空div本身没有浮动，所以容器就会扩展，直到包含它，因此也会包含该div上面的浮动元素。

2. 用伪元素（pseudo-element）来实现。

   使用：:after伪元素选择器，就可以快速地在DOM中在容器末尾添加一个元素，而不用在HTML里添加标记。

   ```css
   .clearfix::after {
       display: block;
       content: ' ';
       clear: both;
   }
   ```

   注意，==要给包含浮动的元素清除浮动==，而不是给别的元素，比如浮动元素本身，或包含浮动的元素后面的兄弟元素。

   这个清除浮动还有个一致性问题没有解决：浮动元素的外边距不会折叠到清除浮动容器的外部，非浮动元素的外边距则会正常折叠。

   > 清除浮动和display:table
   >
   > 在清除浮动时使用display: table能够包含外边距，是因为利用了CSS的一些特性。创建一个display: table元素（或者是本例的伪元素），也就在元素内隐式创建了一个表格行和一个单元格。因为外边距无法通过单元格元素折叠（参见第3章），所以也无法通过设置了display: table的伪元素折叠。看起来似乎使用display: table-cell也能达到相同的效果，但是clear属性只能对块级元素生效。表格是块级元素，但是单元格并不是。因此，clear属性无法跟display:table-cell一起使用。所以要用display: table来清除浮动，同时利用隐式创建单元格来包含外边距。

## 浮动陷阱

如下图：盒子2比盒子1矮，所以它下面有多余的空间给盒子3。盒子3会“抓住”盒子1，而不是清除盒子1的浮动。因此盒子3不会浮动到最左边，而是浮动到盒子1的右下角。

![浮动陷阱](wrong-float.png)

修复方法：清除第三个浮动元素上面的浮动。更通用的做法是，清除每行的第一个元素上面的浮动。可以配合`nth-child()`选择器来使用。

- 每行两个，可以使用奇数或偶数：`nth-child(odd/even)`

- 每行三个：nth-child(3n+1)来每隔两个元素选一个元素。

> 上面这种清除每行浮动的技术要求知道每行有几个元素。如果宽度不是通过百分比来定义的，那么随着视口宽度的改变，每行的元素个数可能会变化。这种情况下，最好使用别的布局方案，比如Flexbox或者inline-block元素。

## BFC

块级格式化上下文（blockformatting context, BFC）BFC是网页的一块区域，元素基于这块区域布局。虽然BFC本身是环绕文档流的一部分，但它将内部的内容与外部的上下文隔离开。这种隔离为创建BFC的元素做出了以下3件事情。

1. 包含了内部所有元素的上下外边距。它们不会跟BFC外面的元素产生外边距折叠。
2. 包含了内部所有的浮动元素。
3. 不会跟BFC外面的浮动元素重叠。

给元素添加以下的任意属性值都会创建BFC。

- float: left或right，不为none即可。

-  overflow:hidden、auto或scroll，不为visible即可。

-  display:inline-block、table-cell、table-caption、flex、inline-flex、grid或inline-grid。拥有这些属性的元素称为块级容器（blockcontainer）。

-  position:absolute或position: fixed。

  > 说明网页的根元素也创建了一个顶级的BFC。

使用overflow: auto通常是创建BFC最简单的一种方式。也可以使用前面提到的其他方式，但是有些问题需要注意，比如，使用浮动或者inline-block方式创建BFC的元素宽度会变成100%，因此需要限制一下元素的宽度，防止因为过宽而换行，导致内容移动到浮动图片的下面。相反，使用table-cell方式显示的元素，其宽度只会刚好容纳其中的内容，因此需要设置一个较大的宽度，强制使其填满剩余空间。

> 某些情况下，BFC中的内容可能还会与别的BFC的内容重叠。比如，内容溢出了容器（比如内容太宽）或者因为负外边距导致内容被拉到容器外面。

## 总结

- 浮动的设计初衷是让文字围绕一个元素排列，但有时这种效果并不是我们想要的。
-  使用清除浮动来包含浮动元素。
-  BFC有3个好处：包含浮动元素，防止外边距折叠，防止文档流围绕浮动元素排列。
-  使用双容器模式让页面内容居中。
-  使用媒体对象模式将描述文字定位到图片旁边。
- 使用网格系统实现更丰富的网页布局。