## 绝对单位

常用的固定像素单位。

> CSS支持几种绝对长度单位，最常用、最基础的是像素（px）。不常用的绝对单位是mm（毫米）、cm（厘米）、in（英寸）、pt（点，印刷术语，1/72英寸）、pc（派卡，印刷术语，12点）。这些单位都可以通过公式互相换算：1in = 25.4mm = 2.54cm = 6pc = 72pt = 96px。



随着技术的发展，设备的屏幕尺寸越来越多样化，所以响应式的页面设计极为需要，所以相对单位应运而生。

> 响应式——在CSS中指的是样式能够根据浏览器窗口的大小有不同的“响应”。这要求有意地考虑任何尺寸的手机、平板设备，或者桌面屏幕。

## 相对单位

### em

em是最常见的相对长度单位，适合基于特定的字体大小进行排版。浏览器会根据相对单位的值计算出绝对值，称作计算值（computed value）。

- 当元素自身设置了`font-size`时，其他属性会根据当前`font-size`的值计算，也就是1em等于字体大小。

- 当元素没有设置了`font-size`时，会从父元素继承`font-size`，再进行计算。对大多数浏览器来说，默认的字号为16px。准确地说，medium关键字的值是16px。

- 当`font-size`用em作单位时，其他使用了em的属性会先根据计算出的字体大小。

  如：

  ```css
  body{
       font-size: 16px;
  }
  .box{
       font-size: 1.5em;
       padding: 1.5em;
       background-color: #ccc;
  }
  ```

  其在网页中显示为：

  ![先计算em字体大小](em-fontsize.png)
  
  当遇到元素嵌套的情况时，给该元素设置em会导致元素越来越大（或小）。

> 当设置padding、height、width、border-radius等属性时，使用em会很方便。这是因为当元素继承了不同的字号，或者用户改变了字体设置时，这些属性会跟着元素均匀地缩放。

### rem

rem不是相对于当前元素，而是相对于根元素的单位。在文档中，根节点是所有其他元素的祖先节点。根节点有一个伪类选择器（:root），可以用来选中它自己。这等价于类型选择器html，但是html的优先级相当于一个类名，而不是一个标签。

与em相比，rem降低了复杂性。实际上，rem结合了px和em的优点，既保留了相对单位的优势，又简单易用。

### vh|vw|vmin|vmax

- ❑ vh：视口高度的1/100。
-  vw：视口宽度的1/100。
-  vmin：视口宽、高中较小的一方的1/100（IE9中叫vm，而不是vmin）。
-  vmax：视口宽、高中较大的一方的1/100

`vmin: 90%`，表示屏幕较小宽度一侧的90%，即横屏高度的90%或者竖屏宽度的90%。

> 相对视口的单位对大部分浏览器而言是较新的特性，因此当你将它跟其他样式结合使用时，会有一些奇怪的bug。可在Can I Use网站中检索Viewport units: vw, vh, vmin, vmax中的“Known Issues”。

### 设置默认字号

如果你希望默认字号为14px，那么不要将默认字体设置为10px然后再覆盖一遍，而应该直接将根元素字号设置为想要的值。将想要的值除以继承值（在这种情况下为浏览器默认值）是14/16，等于0.875。

```css
:root {
    font-size: 0.875em;
}
```

根据屏幕尺寸，==用**媒体查询改变根元素的字号**。这样就能够基于不同用户的屏幕尺寸，渲染出不同大小的面板==。

- 结合媒体查询可以实现整个页面的布局的放大和缩小。

  ```css
  :root {
      font-size: 0.75em;
  }
  @media(min-width: 800px){
      :root {
          font-size: 0.875em;
      }
  }
  @media(min-width: 1200px){
      :root {
          font-size: 1em;
      }
  }
  ```

- 更改网页部分大小：可以对该部分的父元素设置rem，其子元素的布局使用em。这样调整父元素的rem的值即可缩放整块的大小。

- 上面两种缺点是随着视口变化不够平滑，可以==使用`calc()`函数和视口单位`vw`设置字号==来实现平滑过渡。

  ```css
  :root {
      font-size: calc(0.5em + 1vw);
  }
  ```

  这样字体会平滑地缩放。0.5em保证了最小字号，1vw则确保了字体会随着视口缩放。这段代码保证基础字号从iPhone 6里的11.75px一直过渡到1200px的浏览器窗口里的20px。

  不用媒体查询就实现了大部分的响应式策略。省掉三四个硬编码的断点，网页上的内容也能根据视口流畅地缩放。

## 无单位的数值和行高

有些属性允许无单位的值（即一个不指定单位的数）。支持这种值的属性包括line-height、z-index、font-weight（700等于bold,400等于normal，等等）。任何长度单位（如px、em、rem）都可以用无单位的值0

> :warning:一个无单位的0只能用于长度值和百分比，比如内边距、边框和宽度等，而不能用于角度值，比如度，或者时间相关的值，比如秒。

`line-height`属性比较特殊，它的值既可以有单位也可以无单位。通常我们应该使用无单位的数值，因为它们继承的方式不一样。

当一个元素的值定义为长度（px、em、rem，等等）时，子元素会继承它的计算值。当使用em等单位定义行高时，它们的值是计算值，传递到了任何继承子元素上。如果子元素有不同的字号，并且继承了line-height属性，就会造成意想不到的结果，比如文字重叠。

- 行高有单位时，继承的是计算值，如`body`行高为1.5em时，其计算值24px(1.5*16px)将会被子元素继承。
- 行高无单位时，如`body`的行高为1.2，其子元素继承的也将是1.2（相当于倍数）。

我们可以用一个无单位的数值给body设置行高，之后就不用修改了，除非有些地方想要不一样的行高。

## 总结

- ==用rem设置字号，用px设置边框，用em设置其他大部分属性==。

- 不使用媒体查询也可以实现响应式：对根元素或者父元素设置定值，使子元素相对它们调整大小。
- ==用无单位的数值设置行高==。

